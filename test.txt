Testing Strategies:

Our group conduct the test by mainly using printing to test. To name a few, we print LS_table, DV_table, direct_neighbor table, and forward table and logs generated by the Simulator to get the details of the routing running. By checking the time and corresponding output events, we can explain how does the actual PING/PONG or DV/LS work.To check correct message formats, contents and timing we also print the whole packet during the process.

On component level, we test PING, PONG, DV, LS receive functions and their corresponding alarms step by step. We firstly validate ping-pong and direct neighbor table, by printing out only the Neighbor table, Forward table, and DV/LS table along with their results that only contain direct neighbor initialization. Then we check the LS/DV table to make sure correct DV/LS table update behavior when running recv_LS_packet/recv_DV_packet. Then, we separately test the DV/LS table changes when sending and receiving.

Specifically, we use simpletest1,2,3 to test the direct connection for DirectNeighborTable and ForwardTable, and, without updating algorithms, LS/DV table. With given simpletest3, we can also check the simple case where port may expire and 

On system level, we write complicated test cases including the linkdying, linkcomingup, changedelay and use xmit to send data. Since the alarm time and periodic update can affect the behavior of the network, we take this into consideration to design the network events. We also use the sample testcase from the slides that have the count-to-infinity problem as simpletest6, and by printing out the DVtable detail we track the step of poison reverse. Also, we print out all the table related with LS and compare the result with our implementation of LS protocol.

To further test the robustness of our program, we use Java to generate a randomly linked network with 40 and 100 nodes (test-long) to randomly emit packet to each other, which is used to test possible memory or performance problems. 